#include <cryptopp/dsa.h>
#include <cryptopp/osrng.h>
#include <cryptopp/files.h>
#include <cryptopp/sha.h>
#include <cryptopp/hex.h>
#include <cryptopp/integer.h>
#include <cryptopp/filters.h>
#include <cryptopp/queue.h>
#include <string>
#include <iostream>

using namespace CryptoPP;
using namespace std;

// Function to read the public key from a binary file
Integer read_public_key_from_file(const string& filename) {
    ifstream file(filename, ios::binary);
    Integer public_key;

    if (file.is_open()) {
        size_t key_size = 128;
        byte* key_bytes = new byte[key_size];

        file.read(reinterpret_cast<char*>(key_bytes), key_size);
        public_key.Decode(key_bytes, key_size);

        delete[] key_bytes;
        file.close();
    } else {
        cerr << "Unable to open file " << filename << " for reading." << endl;
    }

    return public_key;
}

// Convert Integer to a hexadecimal string
std::string integer_to_hex_string(const CryptoPP::Integer& n) {
    std::string hexString;
    StringSink ss(hexString);
    HexEncoder encoder(new Redirector(ss));
    n.Encode(encoder, n.MinEncodedSize());
    encoder.MessageEnd();
    return hexString;
}

void issueCertificate(const std::string &userEmail, const std::string &caPrivFile, const std::string &userPubKeyFile, const std::string &certFile) {
    AutoSeededRandomPool rng;

    // Load CA's private key (DSA)
    DSA::PrivateKey caPrivateKey;
    FileSource fs1(caPrivFile.c_str(), true);
    caPrivateKey.Load(fs1);

    // Load User's public key (generated by Diffie-Hellman)
    Integer userPublicKey = read_public_key_from_file(userPubKeyFile);

    // Convert the public key to a hex string
    std::string publicKeyHex = integer_to_hex_string(userPublicKey);

    // Define validity dates
    std::string notBefore = "16 Jun 2024 00:00:00";
    std::string notAfter = "27 Aug 2026 00:00:00";

    // Define the signature algorithm
    std::string signatureAlgorithm = "DSA";

    // Create the certificate data
    std::string certificateData = "Issuer: IIITA\nSubject: " + userEmail + "\nValidity:\n  NotBefore: " + notBefore + "\n  NotAfter: " + notAfter + "\nPublic Key: " + publicKeyHex + "\nSignature Algorithm: " + signatureAlgorithm;

    // Hash the certificate data using SHA-256
    SHA256 hash;
    std::string digest;
    StringSource(certificateData, true, new HashFilter(hash, new StringSink(digest)));

    // Sign the hash with CA's private key using DSA
    DSA::Signer signer(caPrivateKey);
    std::string signature;
    StringSource(digest, true, new SignerFilter(rng, signer, new StringSink(signature)));

    // Encode the signature to hex format
    std::string encodedSignature;
    StringSource(signature, true, new HexEncoder(new StringSink(encodedSignature), true));

    // Append the signature to the certificate data
    std::string certificate = certificateData + "\nSignature: " + encodedSignature;

    // Save the certificate
    FileSink file(certFile.c_str());
    file.Put(reinterpret_cast<const byte*>(certificate.c_str()), certificate.size());

    std::cout << "Certificate issued and saved as " << certFile << "." << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc != 5) {
        std::cerr << "Usage: " << argv[0] << " <User Email> <CA Priv Key File> <User Public Key File> <Certificate File>" << std::endl;
        return 1;
    }

    std::string userEmail = argv[1];
    std::string caPrivFile = argv[2];
    std::string userPubKeyFile = argv[3];
    std::string certFile = argv[4];

    issueCertificate(userEmail, caPrivFile, userPubKeyFile, certFile);
    return 0;
}
